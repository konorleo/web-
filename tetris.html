<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тетрис</title>
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #2c3e50;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        .container {
            display: flex;
            flex-direction: row;
            align-items: center;
        }
        canvas {
            background: #34495e;
            border: 2px solid #7f8c8d;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .menu {
            margin-right: 20px;
            text-align: center;
            color: #ecf0f1;
        }
        .menu h2 {
            font-size: clamp(18px, 4vw, 24px);
            text-shadow: 2px 2px 4px #000;
        }
        .menu button {
            width: clamp(100px, 30vw, 150px);
            padding: 10px;
            margin: 5px 0;
            font-size: clamp(12px, 3vw, 16px);
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            background: linear-gradient(#3498db, #2980b9);
            color: #fff;
            cursor: pointer;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }
        .menu button:hover {
            background: linear-gradient(#2980b9, #3498db);
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }
        .controls {
            display: none;
            margin-top: 10px;
        }
        @media (max-width: 600px) {
            .container {
                flex-direction: column;
            }
            .menu {
                margin: 0 0 10px 0;
            }
            canvas {
                width: 80vw;
                height: 160vw;
            }
            .controls {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 5px;
                width: 80vw;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="menu">
            <h2>Тетрис</h2>
            <button onclick="startGame()">Начать</button>
            <button onclick="pauseGame()">Пауза</button>
            <button onclick="resetGame()">Сброс</button>
            <button onclick="window.location.href='index.html'">Меню</button>
            <p>Счёт: <span id="score">0</span></p>
            <div class="controls">
                <button onclick="moveLeft()">←</button>
                <button onclick="rotate()">↻</button>
                <button onclick="moveRight()">→</button>
                <button onclick="moveDown()">↓</button>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        // Адаптивные размеры
        const BLOCK_SIZE = window.innerWidth <= 600 ? Math.floor(window.innerWidth * 0.08) : 25;
        const COLS = 10;
        const ROWS = 20;
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;

        // Цвета и формы
        const COLORS = ['#00ffff', '#0000ff', '#ff9800', '#ffff00', '#00ff00', '#8e24aa', '#ff0000'];
        const SHAPES = [
            [[1, 1, 1, 1]], // I
            [[1, 1], [1, 1]], // O
            [[1, 1, 1], [0, 1, 0]], // T
            [[1, 1, 1], [1, 0, 0]], // L
            [[1, 1, 1], [0, 0, 1]], // J
            [[1, 1, 0], [0, 1, 1]], // S
            [[0, 1, 1], [1, 1, 0]] // Z
        ];

        let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        let piece = null, pieceX = 0, pieceY = 0;
        let score = 0, started = false, paused = false, dropTime = 0;
        const DROP_INTERVAL = 500;
        let lastKeyTime = 0;
        const KEY_DELAY = 100; // Задержка между нажатиями

        function startGame() {
            if (!started) {
                started = true;
                spawnPiece();
                requestAnimationFrame(gameLoop);
            }
        }

        function pauseGame() {
            if (started) paused = !paused;
        }

        function resetGame() {
            started = false;
            paused = false;
            score = 0;
            scoreElement.textContent = score;
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            piece = null;
            dropTime = 0;
        }

        function spawnPiece() {
            const idx = Math.floor(Math.random() * SHAPES.length);
            piece = SHAPES[idx].map(row => [...row]); // Копируем массив
            pieceX = Math.floor(COLS / 2) - Math.floor(piece[0].length / 2);
            pieceY = -piece.length; // Начинаем выше поля
            if (checkCollision()) {
                alert("Игра окончена!");
                resetGame();
            }
        }

        function checkCollision() {
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x]) {
                        const newY = pieceY + y;
                        const newX = pieceX + x;
                        if (newY >= ROWS || newX < 0 || newX >= COLS || (newY >= 0 && board[newY][newX])) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function mergePiece() {
            for (let y = 0; y < piece.length; y++) {
                for (let x = 0; x < piece[y].length; x++) {
                    if (piece[y][x] && pieceY + y >= 0) {
                        board[pieceY + y][pieceX + x] = SHAPES.findIndex(shape => shape.every((row, i) => row.every((val, j) => val === piece[i][j]))) + 1;
                    }
                }
            }
            clearLines();
            spawnPiece();
        }

        function clearLines() {
            let linesCleared = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell)) {
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                }
            }
            score += linesCleared * 10;
            scoreElement.textContent = score;
        }

        function drop() {
            pieceY++;
            if (checkCollision()) {
                pieceY--;
                mergePiece();
            }
        }

        function drawBlock(x, y, color) {
            const offsetX = x * BLOCK_SIZE + 1;
            const offsetY = y * BLOCK_SIZE + 1;
            const size = BLOCK_SIZE - 2;

            // Градиентный блок
            const gradient = ctx.createLinearGradient(offsetX, offsetY, offsetX + size, offsetY + size);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, darkenColor(color));
            ctx.fillStyle = gradient;
            ctx.fillRect(offsetX, offsetY, size, size);

            // Обводка и блик
            ctx.strokeStyle = '#ecf0f1';
            ctx.lineWidth = 1;
            ctx.strokeRect(offsetX, offsetY, size, size);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(offsetX + 2, offsetY + 2, size / 2, size / 2);
        }

        function darkenColor(color) {
            const tempCanvas = document.createElement('canvas').getContext('2d');
            tempCanvas.fillStyle = color;
            tempCanvas.fillRect(0, 0, 1, 1);
            const [r, g, b] = tempCanvas.getImageData(0, 0, 1, 1).data;
            return `rgb(${Math.max(0, r - 50)}, ${Math.max(0, g - 50)}, ${Math.max(0, b - 50)})`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#34495e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Сетка
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 0.5;
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }

            // Зафиксированные блоки
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (board[y][x]) drawBlock(x, y, COLORS[board[y][x] - 1]);
                }
            }

            // Текущая фигура
            if (piece) {
                for (let y = 0; y < piece.length; y++) {
                    for (let x = 0; x < piece[y].length; x++) {
                        if (piece[y][x] && pieceY + y >= 0) drawBlock(pieceX + x, pieceY + y, COLORS[SHAPES.findIndex(shape => shape.every((row, i) => row.every((val, j) => val === piece[i][j])))]);
                    }
                }
            }
        }

        function gameLoop(time) {
            if (!started || paused) return requestAnimationFrame(gameLoop);
            if (time - dropTime >= DROP_INTERVAL) {
                drop();
                dropTime = time;
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        const keyState = {};
        document.addEventListener('keydown', e => {
            if (!started || paused || keyState[e.key] || (performance.now() - lastKeyTime < KEY_DELAY)) return;
            keyState[e.key] = true;
            lastKeyTime = performance.now();
            switch (e.key) {
                case 'ArrowLeft': moveLeft(); break;
                case 'ArrowRight': moveRight(); break;
                case 'ArrowDown': moveDown(); break;
                case 'ArrowUp': rotate(); break;
            }
        });
        document.addEventListener('keyup', e => delete keyState[e.key]);

        function moveLeft() {
            pieceX--;
            if (checkCollision()) pieceX++;
        }

        function moveRight() {
            pieceX++;
            if (checkCollision()) pieceX--;
        }

        function moveDown() {
            drop();
            dropTime = performance.now();
        }

        function rotate() {
            const rotated = piece[0].map((_, i) => piece.map(row => row[i]).reverse());
            const oldPiece = piece.map(row => [...row]);
            piece = rotated;
            if (checkCollision()) {
                piece = oldPiece;
            }
        }
    </script>
</body>
</html>
